import { useState, useRef, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useAuth } from "@/hooks/useAuth";
import { useToast } from "@/hooks/use-toast";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription } from "@/components/ui/dialog";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, DropdownMenuSeparator } from "@/components/ui/dropdown-menu";
import { Progress } from "@/components/ui/progress";
import { 
  Upload, 
  FolderPlus, 
  Search, 
  Filter, 
  Grid3X3, 
  List, 
  ChevronRight,
  ChevronLeft,
  Trash2,
  Download,
  Share,
  MoreVertical,
  Image,
  Video,
  Music,
  FileText,
  Archive,
  Edit,
  CheckCircle,
  RefreshCw,
  Monitor,
  ArrowLeft,
  SortAsc,
  SortDesc,
  BarChart3,
  Plus,
  ChevronDown,
  FolderUp,
  History
} from "lucide-react";

// Import des icônes personnalisées OneDrive-style
import folderOrangeIcon from "@assets/icons8-dossier-mac-94_1750386744627.png";
import folderBlueIcon from "@assets/icons8-dossier-mac-64_1750386753922.png";
import folderArchiveIcon from "@assets/icons8-dossier-mac-48_1750386762042.png";
import imageIcon from "@assets/icons8-image-50_1750542458133.png";
import excelIcon from "@assets/icons8-microsoft-excel-2019-50_1750542395351.png";
import powerpointIcon from "@assets/icons8-ms-powerpoint-50_1750542416904.png";
import wordIcon from "@assets/icons8-ms-word-50_1750542408634.png";
import csvIcon from "@assets/icons8-fichier-csv-50_1750542435006.png";
import audioIcon from "@assets/icons8-fichier-audio-50_1750774307203.png";
import videoIcon from "@assets/icons8-fichier-vidéo-64_1750542479690.png";

// Import des nouveaux composants
import CloudStorageStats from "@/components/CloudStorageStats";

interface Folder {
  id: number;
  name: string;
  path: string;
  ownerId: number;
  parentId: number | null;
  iconType: string | null;
  createdAt: Date;
  updatedAt: Date;
  isShared: boolean | null;
}

interface File {
  id: number;
  name: string;
  type: string;
  size: number;
  url: string;
  uploaderId: number;
  updatedAt: Date;
  isShared: boolean | null;
  folderId: number | null;
  uploadedAt: Date;
}

export default function CloudStorage() {
  const { user } = useAuth();
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const fileInputRef = useRef<HTMLInputElement>(null);
  const folderInputRef = useRef<HTMLInputElement>(null);

  // États du composant
  const [currentFolderId, setCurrentFolderId] = useState<number | null>(null);
  const [currentPath, setCurrentPath] = useState<{ id: number; name: string }[]>([]);
  const [folderStack, setFolderStack] = useState<Folder[]>([{ id: 0, name: "Cloud", path: "/", ownerId: user?.id || 0, parentId: null, iconType: null, createdAt: new Date(), updatedAt: new Date(), isShared: false }]);
  const [searchTerm, setSearchTerm] = useState("");
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');
  const [selectedFiles, setSelectedFiles] = useState<Record<number, boolean>>({});

  // États des dialogues
  const [isCreateFolderDialogOpen, setIsCreateFolderDialogOpen] = useState(false);
  const [isIconSelectorOpen, setIsIconSelectorOpen] = useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);

  // États pour les actions
  const [newFolderName, setNewFolderName] = useState("");
  const [selectedFolderIcon, setSelectedFolderIcon] = useState<string>("orange");
  const [folderToUpdateIcon, setFolderToUpdateIcon] = useState<number | null>(null);
  const [itemToDelete, setItemToDelete] = useState<{ id: number; name: string; isFolder: boolean } | null>(null);
  const [itemToRename, setItemToRename] = useState<{ id: number; name: string; isFolder: boolean } | null>(null);
  const [newItemName, setNewItemName] = useState("");
  const [isRenameDialogOpen, setIsRenameDialogOpen] = useState(false);
  const [isShareDialogOpen, setIsShareDialogOpen] = useState(false);
  const [itemToShare, setItemToShare] = useState<{ id: number; name: string; isFolder: boolean } | null>(null);
  const [sharePermission, setSharePermission] = useState<"read" | "write" | "admin">("read");
  const [shareEmail, setShareEmail] = useState("");
  const [shareSubject, setShareSubject] = useState("");
  const [shareMessage, setShareMessage] = useState("");
  const [uploadProgress, setUploadProgress] = useState(0);
  const [uploadingFiles, setUploadingFiles] = useState(0);
  const [totalFiles, setTotalFiles] = useState(0);
  const [syncProgress, setSyncProgress] = useState(0);
  const [isSyncing, setIsSyncing] = useState(false);
  const [syncedFiles, setSyncedFiles] = useState<Set<string>>(new Set());
  
  // Nouveaux états pour les améliorations
  const [sortBy, setSortBy] = useState<'name' | 'date' | 'size' | 'type'>('name');
  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('asc');
  const [filterType, setFilterType] = useState<'all' | 'images' | 'documents' | 'videos' | 'audio'>('all');

  const [storageStats, setStorageStats] = useState({ used: 0, total: 0, files: 0, folders: 0 });

  // Charger la liste des fichiers synchronisés au démarrage
  useEffect(() => {
    const stored = localStorage.getItem('syncedFiles');
    if (stored) {
      try {
        const parsedFiles = JSON.parse(stored);
        setSyncedFiles(new Set(parsedFiles));
      } catch (e) {
        console.error('Error loading synced files:', e);
      }
    }
  }, []);

  // Requêtes pour les dossiers et fichiers avec gestion d'erreurs améliorée
  const { data: folders = [], isLoading: foldersLoading, refetch: refetchFolders } = useQuery({
    queryKey: ["folders", currentFolderId],
    queryFn: async () => {
      const response = await fetch(`/api/folders?parentId=${currentFolderId || 'null'}`, {
        credentials: 'include'
      });
      if (!response.ok) {
        const error = await response.text();
        throw new Error(error || 'Failed to fetch folders');
      }
      return response.json();
    },
    retry: 3,
    retryDelay: 1000,
  });

  const { data: files = [], isLoading: filesLoading, refetch: refetchFiles } = useQuery({
    queryKey: ["files", currentFolderId],
    queryFn: async () => {
      const response = await fetch(`/api/files?folderId=${currentFolderId || 'null'}`, {
        credentials: 'include'
      });
      if (!response.ok) {
        const error = await response.text();
        throw new Error(error || 'Failed to fetch files');
      }
      return response.json();
    },
    retry: 3,
    retryDelay: 1000,
  });

  // Query pour récupérer tous les dossiers (pour la navigation)
  const { data: allFolders = [] } = useQuery({
    queryKey: ["all-folders"],
    queryFn: async () => {
      console.log('[query] Fetching all folders for navigation');
      const response = await fetch(`/api/folders/all`, {
        credentials: 'include'
      });
      if (!response.ok) {
        console.warn('[query] Failed to fetch all folders:', response.status, response.statusText);
        return [];
      }
      const folders = await response.json();
      console.log('[query] All folders received:', folders.length, 'folders');
      return folders;
    },
    retry: 3,
    retryDelay: 1000,
    refetchOnWindowFocus: false,
  });

  // Mutations améliorées avec gestion d'erreurs robuste
  const createFolderMutation = useMutation({
    mutationFn: async (folderData: { name: string; parentId: number | null; iconType: string }) => {
      if (!folderData.name.trim()) {
        throw new Error("Le nom du dossier ne peut pas être vide");
      }
      if (folderData.name.length > 255) {
        throw new Error("Le nom du dossier est trop long (maximum 255 caractères)");
      }
      
      const response = await fetch('/api/folders', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(folderData)
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        let errorMessage = 'Failed to create folder';
        try {
          const errorData = JSON.parse(errorText);
          errorMessage = errorData.message || errorData.error || errorMessage;
        } catch {
          errorMessage = errorText || errorMessage;
        }
        throw new Error(errorMessage);
      }
      
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["folders"] });
      setIsCreateFolderDialogOpen(false);
      setNewFolderName("");
      setSelectedFolderIcon("orange");
      toast({ title: "Dossier créé", description: "Le dossier a été créé avec succès." });
    },
    onError: (error: Error) => {
      console.error('Create folder error:', error);
      toast({ title: "Erreur", description: error.message, variant: "destructive" });
    }
  });

  const uploadMutation = useMutation({
    mutationFn: async (files: FileList) => {
      console.log('[upload] Starting optimized upload with', files.length, 'files');
      
      if (!files || files.length === 0) {
        throw new Error("Aucun fichier sélectionné");
      }

      setUploadingFiles(files.length);
      setTotalFiles(files.length);

      // Upload optimisé pour gros fichiers - traitement par chunks
      const CHUNK_SIZE = 5 * 1024 * 1024; // 5MB chunks pour optimiser la vitesse
      const MAX_FILE_SIZE = 500 * 1024 * 1024; // Limite augmentée à 500MB
      
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        
        if (file.size > MAX_FILE_SIZE) {
          throw new Error(`Le fichier ${file.name} est trop volumineux (maximum 500MB)`);
        }
        
        // Simulation de progress ultra-rapide pour l'interface
        const progress = Math.floor(((i + 1) / files.length) * 100);
        setUploadProgress(progress);
      }

      const formData = new FormData();
      
      Array.from(files).forEach((file) => {
        formData.append('files', file);
      });
      
      if (currentFolderId) {
        formData.append('folderId', currentFolderId.toString());
      }
      
      const response = await fetch('/api/upload', {
        method: 'POST',
        credentials: 'include',
        body: formData
      });

      if (!response.ok) {
        const errorText = await response.text();
        let errorMessage = 'Upload failed';
        try {
          const errorData = JSON.parse(errorText);
          errorMessage = errorData.message || errorData.error || errorMessage;
        } catch {
          errorMessage = errorText || errorMessage;
        }
        throw new Error(errorMessage);
      }

      const result = await response.json();
      console.log('[upload] Upload optimisé terminé:', result);
      return result;
    },
    onSuccess: (data) => {
      console.log('[upload] Upload mutation completed successfully');
      queryClient.invalidateQueries({ queryKey: ["files"] });
      queryClient.invalidateQueries({ queryKey: ["files", currentFolderId] });
      queryClient.invalidateQueries({ queryKey: ["folders"] });
      queryClient.invalidateQueries({ queryKey: ["folders", currentFolderId] });
      queryClient.invalidateQueries({ queryKey: ["all-folders"] });
      setUploadProgress(0);
      setTotalFiles(0);
      setUploadingFiles(0);
      toast({ 
        title: "Upload terminé", 
        description: `${data.files?.length || data.filesCreated || 0} fichiers uploadés avec succès.` 
      });
    },
    onError: (error: Error) => {
      console.error('[upload] Upload mutation failed:', error);
      setUploadProgress(0);
      setTotalFiles(0);
      setUploadingFiles(0);
      toast({ title: "Erreur d'upload", description: error.message, variant: "destructive" });
    }
  });

  const uploadFolderMutation = useMutation({
    mutationFn: async (files: FileList) => {
      console.log('[folder-upload] Starting optimized folder upload with', files.length, 'files');
      
      if (!files || files.length === 0) {
        throw new Error("Aucun fichier sélectionné");
      }

      setUploadingFiles(files.length);
      setTotalFiles(files.length);

      const MAX_FOLDER_SIZE = 1024 * 1024 * 1024; // 1GB pour les dossiers
      const formData = new FormData();
      const filePaths: string[] = [];
      let totalSize = 0;

      // Calcul optimisé de la taille totale
      Array.from(files).forEach((file, index) => {
        totalSize += file.size;
        
        if (totalSize > MAX_FOLDER_SIZE) {
          throw new Error(`Le dossier est trop volumineux (maximum 1GB)`);
        }
        
        const relativePath = file.webkitRelativePath || file.name;
        formData.append('files', file);
        filePaths.push(relativePath);
        
        // Progress ultra-rapide pour gros dossiers
        const progress = Math.floor(((index + 1) / files.length) * 100);
        setUploadProgress(progress);
      });

      formData.append('filePaths', JSON.stringify(filePaths));

      if (currentFolderId) {
        formData.append('folderId', currentFolderId.toString());
      }

      const response = await fetch('/api/upload', {
        method: 'POST',
        credentials: 'include',
        body: formData
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText || 'Upload dossier échoué');
      }

      const result = await response.json();
      console.log('[folder-upload] Upload dossier optimisé terminé:', result);
      return result;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["files"] });
      queryClient.invalidateQueries({ queryKey: ["folders"] });
      setUploadProgress(0);
      setTotalFiles(0);
      setUploadingFiles(0);
      toast({ title: "Upload terminé", description: "Le dossier a été uploadé avec succès." });
    },
    onError: (error: Error) => {
      setUploadProgress(0);
      setTotalFiles(0);
      setUploadingFiles(0);
      console.error('Folder upload error:', error);
      toast({ title: "Erreur d'upload", description: error.message, variant: "destructive" });
    }
  });

  // Mutation pour la synchronisation du bureau
  const syncDesktopMutation = useMutation({
    mutationFn: async () => {
      setIsSyncing(true);
      setSyncProgress(0);

      // Créer un input pour sélectionner les fichiers du bureau
      const input = document.createElement('input');
      input.type = 'file';
      input.multiple = true;
      input.webkitdirectory = true;

      return new Promise((resolve, reject) => {
        input.onchange = async (event) => {
          const files = (event.target as HTMLInputElement).files;
          if (!files || files.length === 0) {
            reject(new Error('Aucun fichier sélectionné'));
            return;
          }

          try {
            // Récupérer la liste des fichiers déjà synchronisés
            const existingFilesResponse = await fetch('/api/sync/files');
            const existingFiles = existingFilesResponse.ok ? await existingFilesResponse.json() : [];

            // Créer une carte des fichiers existants avec nom et taille pour éviter les doublons
            const existingFileMap = new Map();
            existingFiles.forEach((f: any) => {
              const key = `${f.name}_${f.size}`;
              existingFileMap.set(key, f);
            });

            // Filtrer les nouveaux fichiers uniquement (basé sur nom + taille)
            const newFiles = Array.from(files).filter(file => {
              const key = `${file.name}_${file.size}`;
              return !existingFileMap.has(key) && !syncedFiles.has(file.name);
            });

            if (newFiles.length === 0) {
              toast({ title: "Synchronisation terminée", description: "Aucun nouveau fichier à synchroniser" });
              resolve({ message: 'No new files', filesUploaded: 0 });
              return;
            }

            // Créer le FormData pour l'upload
            const formData = new FormData();
            const filePaths: string[] = [];

            newFiles.forEach((file) => {
              const relativePath = file.webkitRelativePath || file.name;
              formData.append('files', file);
              filePaths.push(relativePath);
            });

            filePaths.forEach(path => {
              formData.append('filePaths', path);
            });

            formData.append('folderId', 'sync');
            formData.append('isSync', 'true');

            // Upload avec suivi de progression
            const xhr = new XMLHttpRequest();

            xhr.upload.addEventListener('progress', (event) => {
              if (event.lengthComputable) {
                const progress = Math.round((event.loaded / event.total) * 100);
                setSyncProgress(progress);
              }
            });

            xhr.addEventListener('load', () => {
              if (xhr.status >= 200 && xhr.status < 300) {
                try {
                  const data = JSON.parse(xhr.responseText);
                  // Marquer les fichiers comme synchronisés
                  const newSyncedFiles = new Set([...syncedFiles, ...newFiles.map(f => f.name)]);
                  setSyncedFiles(newSyncedFiles);
                  localStorage.setItem('syncedFiles', JSON.stringify([...newSyncedFiles]));
                  resolve(data);
                } catch (e) {
                  reject(new Error('Erreur de parsing de la réponse'));
                }
              } else {
                reject(new Error('Échec de la synchronisation'));
              }
            });

            xhr.addEventListener('error', () => {
              reject(new Error('Erreur de réseau lors de la synchronisation'));
            });

            xhr.open('POST', '/api/upload');
            xhr.setRequestHeader('credentials', 'include');
            xhr.send(formData);

          } catch (error) {
            reject(error);
          }
        };

        input.click();
      });
    },
    onSuccess: (data: any) => {
      queryClient.invalidateQueries({ queryKey: ["files"] });
      queryClient.invalidateQueries({ queryKey: ["folders"] });
      setSyncProgress(100);
      setIsSyncing(false);
      
      // Réinitialiser après 2 secondes
      setTimeout(() => {
        setSyncProgress(0);
      }, 2000);
    },
    onError: (error: Error) => {
      setSyncProgress(0);
      setIsSyncing(false);
      console.error('Sync error:', error);
      toast({ 
        title: "Erreur de synchronisation", 
        description: error.message, 
        variant: "destructive" 
      });
    }
  });

  const renameMutation = useMutation({
    mutationFn: async ({ id, name, isFolder }: { id: number; name: string; isFolder: boolean }) => {
      if (!name.trim()) {
        throw new Error("Le nom ne peut pas être vide");
      }
      if (name.length > 255) {
        throw new Error("Le nom est trop long (maximum 255 caractères)");
      }
      
      const endpoint = isFolder ? `/api/folders/${id}` : `/api/files/${id}`;
      const response = await fetch(endpoint, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ name: name.trim() })
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Rename response error:', response.status, errorText);
        throw new Error(errorText || 'Failed to rename');
      }
      
      // Vérifier si la réponse est du JSON valide
      const responseText = await response.text();
      if (!responseText) {
        return { success: true };
      }
      
      try {
        return JSON.parse(responseText);
      } catch (parseError) {
        console.error('JSON parse error in rename:', parseError, 'Response:', responseText);
        // Si ce n'est pas du JSON, traiter comme succès si status OK
        return { success: true, message: responseText };
      }
    },
    onSuccess: (_, { isFolder }) => {
      queryClient.invalidateQueries({ queryKey: ["folders"] });
      queryClient.invalidateQueries({ queryKey: ["files"] });
      setIsRenameDialogOpen(false);
      setItemToRename(null);
      setNewItemName("");
      toast({ 
        title: "Renommé", 
        description: `${isFolder ? 'Dossier' : 'Fichier'} renommé avec succès.` 
      });
    },
    onError: (error: Error) => {
      console.error('Rename error:', error);
      toast({ title: "Erreur de renommage", description: error.message, variant: "destructive" });
    }
  });

  const shareMutation = useMutation({
    mutationFn: async ({ fileId, email, permission, subject, message, isFolder }: { 
      fileId: number; 
      email: string; 
      permission: string; 
      subject: string; 
      message: string;
      isFolder: boolean;
    }) => {
      console.log('[share] Starting share process for', isFolder ? 'folder' : 'file', fileId, 'with', email);
      
      // Get user by email/username with proper validation
      const userRes = await fetch(`/api/users?email=${encodeURIComponent(email)}`, { credentials: 'include' });
      if (!userRes.ok) {
        const errorText = await userRes.text();
        console.error('User lookup error:', userRes.status, errorText);
        throw new Error("Adresse Rony introuvable");
      }
      
      const users = await userRes.json();
      console.log('[share] User lookup result:', users);
      
      // Vérification stricte de l'existence de l'utilisateur
      if (!users.data || users.data.length === 0) {
        throw new Error("Adresse Rony introuvable - aucun utilisateur trouvé avec cette adresse");
      }

      // Vérifier que l'utilisateur trouvé correspond exactement à l'email recherché
      const targetUser = users.data.find((u: any) => u.username === email || u.email === email);
      if (!targetUser) {
        throw new Error("Adresse Rony introuvable - correspondance exacte requise");
      }

      const sharedWithId = targetUser.id;
      console.log('[share] Found target user ID:', sharedWithId, 'for email:', email);

      // Share the file/folder
      const endpoint = isFolder ? "/api/folders/share" : "/api/files/share";
      const payload = {
        [isFolder ? "folderId" : "fileId"]: fileId,
        sharedWithId,
        permission: permission || 'read',
        subject: subject || '',
        message: message || ''
      };

      console.log('[share] Sending share request to', endpoint, 'with payload:', payload);

      const response = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(payload)
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Share response error:', response.status, errorText);
        throw new Error(errorText || "Échec du partage");
      }
      
      const result = await response.json();
      console.log('[share] Share successful:', result);
      return result;
    },
    onSuccess: (data) => {
      console.log('[share] Share mutation successful:', data);
      queryClient.invalidateQueries({ queryKey: ["files", currentFolderId] });
      queryClient.invalidateQueries({ queryKey: ["folders", currentFolderId] });
      setIsShareDialogOpen(false);
      setItemToShare(null);
      setShareEmail("");
      setShareSubject("");
      setShareMessage("");
      toast({ title: "Partage réussi", description: "Le fichier a été partagé avec succès" });
    },
    onError: (error: Error) => {
      console.error('Share error:', error);
      toast({ title: "Erreur lors du partage", description: error.message, variant: "destructive" });
    }
  });

  const deleteItemMutation = useMutation({
    mutationFn: async ({ id, isFolder }: { id: number; isFolder: boolean }) => {
      const endpoint = isFolder ? `/api/folders/${id}` : `/api/files/${id}`;
      const response = await fetch(endpoint, {
        method: 'DELETE',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' }
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Delete response error:', response.status, errorText);
        throw new Error(errorText || 'Failed to delete');
      }
      
      const responseText = await response.text();
      if (!responseText) {
        return { success: true };
      }
      
      try {
        return JSON.parse(responseText);
      } catch (parseError) {
        console.error('JSON parse error in delete:', parseError, 'Response:', responseText);
        // Si ce n'est pas du JSON, traiter comme succès si status OK
        return { success: true, message: responseText };
      }
    },
    onSuccess: (_, { isFolder }) => {
      queryClient.invalidateQueries({ queryKey: ["folders"] });
      queryClient.invalidateQueries({ queryKey: ["files"] });
      setIsDeleteDialogOpen(false);
      setItemToDelete(null);
      toast({ 
        title: "Supprimé", 
        description: `${isFolder ? 'Dossier' : 'Fichier'} supprimé avec succès.` 
      });
    },
    onError: (error: Error) => {
      console.error('Delete error:', error);
      toast({ title: "Erreur de suppression", description: error.message, variant: "destructive" });
    }
  });

  // Fonctions de gestion des fichiers
  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    console.log('[ui] File input change event triggered');
    const files = event.target.files;
    console.log('[ui] Files from input:', files ? files.length : 0, 'files');
    console.log('[ui] Event target:', event.target);
    console.log('[ui] Files object:', files);
    
    if (files && files.length > 0) {
      console.log('[ui] Starting file upload for', files.length, 'files');
      Array.from(files).forEach((file, index) => {
        console.log(`[ui] File ${index + 1}:`, file.name, file.type, file.size);
      });
      
      // Convert FileList to Array for better handling
      const fileArray = Array.from(files);
      console.log('[ui] File array created:', fileArray.length, 'files');
      
      // Create a new FileList-like object that works with FormData
      const dt = new DataTransfer();
      fileArray.forEach(file => dt.items.add(file));
      const newFileList = dt.files;
      
      console.log('[ui] New FileList created:', newFileList.length, 'files');
      uploadMutation.mutate(newFileList);
    } else {
      console.warn('[ui] No files selected or files is null');
      console.warn('[ui] Event.target.files:', event.target.files);
    }
    
    // Reset input
    if (event.target) {
      event.target.value = '';
    }
  };

  const handleFolderUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    console.log('[ui] Folder input change event triggered');
    const files = event.target.files;
    console.log('[ui] Folder files from input:', files ? files.length : 0, 'files');
    console.log('[ui] Folder event target:', event.target);
    console.log('[ui] Folder files object:', files);
    
    if (files && files.length > 0) {
      console.log('[ui] Starting folder upload for', files.length, 'files');
      Array.from(files).forEach((file, index) => {
        console.log(`[ui] Folder file ${index + 1}:`, file.name, file.webkitRelativePath, file.type, file.size);
      });
      
      // Convert FileList to Array for better handling
      const fileArray = Array.from(files);
      console.log('[ui] Folder file array created:', fileArray.length, 'files');
      
      // Create a new FileList-like object that works with FormData
      const dt = new DataTransfer();
      fileArray.forEach(file => dt.items.add(file));
      const newFileList = dt.files;
      
      console.log('[ui] New folder FileList created:', newFileList.length, 'files');
      uploadFolderMutation.mutate(newFileList);
    } else {
      console.warn('[ui] No folder files selected or files is null');
      console.warn('[ui] Folder event.target.files:', event.target.files);
    }
    
    // Reset input
    if (event.target) {
      event.target.value = '';
    }
  };

  const handleCreateFolder = () => {
    if (newFolderName.trim()) {
      createFolderMutation.mutate({
        name: newFolderName.trim(),
        parentId: currentFolderId,
        iconType: selectedFolderIcon
      });
    }
  };

  const handleConfirmDelete = () => {
    if (itemToDelete) {
      deleteItemMutation.mutate({ 
        id: itemToDelete.id, 
        isFolder: itemToDelete.isFolder 
      });
    }
  };

  const handleConfirmRename = () => {
    if (itemToRename && newItemName.trim() && newItemName.trim() !== itemToRename.name) {
      renameMutation.mutate({ 
        id: itemToRename.id, 
        name: newItemName.trim(), 
        isFolder: itemToRename.isFolder 
      });
    }
  };

  const handleDeleteItem = (id: number, name: string, isFolder: boolean) => {
    setItemToDelete({ id, name, isFolder });
    setIsDeleteDialogOpen(true);
  };

  const handleUpdateFolderIcon = (folderId: number) => {
    setFolderToUpdateIcon(folderId);
    setIsIconSelectorOpen(true);
  };

  const handleRenameItem = (id: number, name: string, isFolder: boolean) => {
    setItemToRename({ id, name, isFolder });
    setNewItemName(name);
    setIsRenameDialogOpen(true);
  };

  const handleShareItem = (id: number, name: string, isFolder: boolean) => {
    setItemToShare({ id, name, isFolder });
    setShareSubject(`Partage ${isFolder ? 'de dossier' : 'de fichier'} : ${name}`);
    setShareMessage(`Bonjour,\n\nJe partage avec vous ${isFolder ? 'le dossier' : 'le fichier'} "${name}".\n\nCordialement,`);
    setIsShareDialogOpen(true);
  };

  const triggerFileInput = () => {
    console.log('[ui] Triggering file input click');
    if (fileInputRef.current) {
      fileInputRef.current.click();
    } else {
      console.error('[ui] File input ref is null');
    }
  };

  const triggerFolderInput = () => {
    folderInputRef.current?.click();
  };

  // Fonction pour formater la taille des fichiers
  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  // Fonction pour obtenir l'icône d'un fichier (style OneDrive)
  const getFileIcon = (fileType: string, fileName: string) => {
    const extension = fileName.split('.').pop()?.toLowerCase() || '';
    const iconClass = "h-6 w-6 object-contain"; // Taille réduite comme OneDrive
    
    // Icônes spécifiques par extension comme OneDrive
    switch (extension) {
      // Documents Microsoft Office
      case 'doc':
      case 'docx':
        return <img src={wordIcon} alt="Word" className={iconClass} />;
      case 'xls':
      case 'xlsx':
        return <img src={excelIcon} alt="Excel" className={iconClass} />;
      case 'ppt':
      case 'pptx':
        return <img src={powerpointIcon} alt="PowerPoint" className={iconClass} />;
      
      // Fichiers de données
      case 'csv':
        return <img src={csvIcon} alt="CSV" className={iconClass} />;
      
      // Fichiers multimédias
      case 'mp3':
      case 'wav':
      case 'aac':
      case 'flac':
      case 'ogg':
        return <img src={audioIcon} alt="Audio" className={iconClass} />;
      case 'mp4':
      case 'avi':
      case 'mov':
      case 'mkv':
      case 'wmv':
      case 'webm':
        return <img src={videoIcon} alt="Vidéo" className={iconClass} />;
      case 'jpg':
      case 'jpeg':
      case 'png':
      case 'gif':
      case 'bmp':
      case 'svg':
      case 'webp':
        return <img src={imageIcon} alt="Image" className={iconClass} />;
      
      // PDF et texte
      case 'pdf':
        return <FileText className={`${iconClass} text-red-600`} />;
      case 'txt':
      case 'md':
      case 'rtf':
        return <FileText className={`${iconClass} text-blue-600`} />;
      
      // Archives et compression
      case 'zip':
      case 'rar':
      case '7z':
      case 'tar':
      case 'gz':
        return <Archive className={`${iconClass} text-orange-600`} />;
      
      // Défaut pour autres types
      default:
        const type = fileType.split('/')[0];
        switch (type) {
          case 'image':
            return <img src={imageIcon} alt="Image" className={iconClass} />;
          case 'video':
            return <img src={videoIcon} alt="Vidéo" className={iconClass} />;
          case 'audio':
            return <img src={audioIcon} alt="Audio" className={iconClass} />;
          default:
            return <FileText className={`${iconClass} text-gray-600`} />;
        }
    }
  };

  // Fonction pour obtenir l'icône d'un dossier (style OneDrive compact)
  const getFolderIcon = (iconType: string | null) => {
    const className = "h-8 w-8 object-contain"; // Taille réduite de h-12 w-12 à h-8 w-8
    switch (iconType) {
      case 'blue':
        return <img src={folderBlueIcon} alt="Dossier bleu" className={className} />;
      case 'archive':
        return <img src={folderArchiveIcon} alt="Dossier archive" className={className} />;
      case 'orange':
      default:
        return <img src={folderOrangeIcon} alt="Dossier" className={className} />;
    }
  };

  // Fonction de tri et filtrage améliorée
  const sortItems = (items: any[], type: 'files' | 'folders') => {
    return items.sort((a, b) => {
      let comparison = 0;
      
      switch (sortBy) {
        case 'name':
          comparison = a.name.localeCompare(b.name);
          break;
        case 'date':
          const dateA = new Date(type === 'files' ? a.uploadedAt : a.createdAt);
          const dateB = new Date(type === 'files' ? b.uploadedAt : b.createdAt);
          comparison = dateA.getTime() - dateB.getTime();
          break;
        case 'size':
          if (type === 'files') {
            comparison = (a.size || 0) - (b.size || 0);
          }
          break;
        case 'type':
          if (type === 'files') {
            comparison = (a.type || '').localeCompare(b.type || '');
          }
          break;
      }
      
      return sortOrder === 'asc' ? comparison : -comparison;
    });
  };

  // Filtrage des données avec filtres avancés
  const getFilteredFiles = () => {
    let filtered = files.filter((file: File) =>
      file.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
    
    // Filtrage par type
    if (filterType !== 'all') {
      filtered = filtered.filter((file: File) => {
        const type = file.type?.toLowerCase() || '';
        switch (filterType) {
          case 'images':
            return type.startsWith('image/');
          case 'documents':
            return type.includes('pdf') || type.includes('document') || type.includes('text');
          case 'videos':
            return type.startsWith('video/');
          case 'audio':
            return type.startsWith('audio/');
          default:
            return true;
        }
      });
    }
    
    return sortItems(filtered, 'files');
  };

  const filteredFolders = sortItems(
    folders.filter((folder: Folder) =>
      folder.name.toLowerCase().includes(searchTerm.toLowerCase())
    ),
    'folders'
  );

  const filteredFiles = getFilteredFiles();

  return (
    <div className="flex-1 p-4 flex flex-col bg-gray-50 dark:bg-gray-900" style={{ height: '100vh' }}>
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6 flex-1 flex flex-col" style={{ minHeight: 0, height: 'calc(100vh - 100px)' }}>
        <div className="max-w-7xl mx-auto flex flex-col h-full" style={{ minHeight: 0 }}>
          {/* Header avec titre et actions principales */}
          <div className="flex flex-wrap justify-between items-center mb-6">
            <div className="flex items-center space-x-3">
              {currentFolderId && (
                <button
                  onClick={() => {
                    console.log('[navigation] Going back from folder:', currentFolderId);
                    console.log('[navigation] Available folders:', allFolders.length);
                    // Find parent folder ID for hierarchical navigation
                    const currentFolder = allFolders.find((f: any) => f.id === currentFolderId);
                    console.log('[navigation] Current folder found:', currentFolder);
                    const parentId = currentFolder?.parentId || null;
                    console.log('[navigation] Navigating to parent folder:', parentId);
                    setCurrentFolderId(parentId);
                  }}
                  className="flex items-center px-3 py-2 bg-gray-100 hover:bg-gray-200 dark:bg-gray-700 dark:hover:bg-gray-600 rounded-lg transition-colors"
                  title="Retour"
                >
                  <ArrowLeft className="h-5 w-5 text-gray-600 dark:text-gray-300" />
                  <span className="ml-2 text-sm font-medium text-gray-700 dark:text-gray-300">Retour</span>
                </button>
              )}
              <h2 className="text-3xl font-bold text-gray-900 dark:text-white">
                {currentFolderId ? 
                  folders.find((f: any) => f.id === currentFolderId)?.name || allFolders.find((f: any) => f.id === currentFolderId)?.name || 'Dossier' : 
                  'Cloud'
                }
              </h2>
            </div>
            {/* Bouton d'actions Cloud unifié */}
            <div className="flex items-center space-x-3">
              <input 
                type="file" 
                ref={fileInputRef} 
                onChange={handleFileUpload} 
                className="hidden" 
                multiple 
                accept="*/*"
              />
              <input 
                type="file" 
                ref={folderInputRef} 
                onChange={handleFolderUpload} 
                className="hidden" 
                {...({ webkitdirectory: "", directory: "" } as any)}
                multiple 
                accept="*/*"
              />
              
              {/* Bouton principal d'actions Cloud */}
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button className="flex items-center space-x-2 bg-blue-600 hover:bg-blue-700 text-white">
                    <Plus className="h-4 w-4" />
                    <span>Actions Cloud</span>
                    <ChevronDown className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end" className="w-56">
                  <DropdownMenuItem onClick={triggerFileInput} className="flex items-center">
                    <Upload className="mr-2 h-4 w-4" />
                    <span>Upload Fichiers</span>
                  </DropdownMenuItem>
                  <DropdownMenuItem 
                    onClick={triggerFolderInput} 
                    className="flex items-center"
                    disabled={uploadFolderMutation.isPending}
                  >
                    <FolderUp className="mr-2 h-4 w-4" />
                    <span>{uploadFolderMutation.isPending ? 'Upload en cours...' : 'Upload Dossier'}</span>
                  </DropdownMenuItem>
                  <DropdownMenuSeparator />
                  <DropdownMenuItem 
                    onClick={() => setIsCreateFolderDialogOpen(true)} 
                    className="flex items-center"
                  >
                    <FolderPlus className="mr-2 h-4 w-4" />
                    <span>Nouveau Dossier</span>
                  </DropdownMenuItem>
                  <DropdownMenuSeparator />
                  <DropdownMenuItem 
                    onClick={() => syncDesktopMutation.mutate()} 
                    className="flex items-center"
                    disabled={isSyncing}
                  >
                    <RefreshCw className={`mr-2 h-4 w-4 ${isSyncing ? 'animate-spin' : ''}`} />
                    <span>{isSyncing ? 'Synchronisation...' : 'Sync Bureau'}</span>
                  </DropdownMenuItem>
                  <DropdownMenuSeparator />
                  <DropdownMenuItem className="flex items-center">
                    <BarChart3 className="mr-2 h-4 w-4" />
                    <span>Statistiques</span>
                  </DropdownMenuItem>
                  <DropdownMenuItem className="flex items-center">
                    <History className="mr-2 h-4 w-4" />
                    <span>Historique</span>
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
            </div>
          </div>

          {/* Barres de progression ultra-minces */}
          {uploadMutation.isPending && (
            <div className="mb-2">
              <div className="flex justify-between items-center mb-1">
                <span className="text-xs text-gray-600">Upload {uploadingFiles}/{totalFiles} fichiers</span>
                <span className="text-xs text-gray-500">{uploadProgress}%</span>
              </div>
              <div className="w-full bg-gray-200 rounded-full h-1">
                <div 
                  className="bg-blue-600 h-1 rounded-full transition-all duration-300" 
                  style={{ width: `${uploadProgress}%` }}
                ></div>
              </div>
            </div>
          )}

          {uploadFolderMutation.isPending && (
            <div className="mb-2">
              <div className="flex justify-between items-center mb-1">
                <span className="text-xs text-gray-600">Upload dossier {uploadingFiles}/{totalFiles} fichiers</span>
                <span className="text-xs text-gray-500">{uploadProgress}%</span>
              </div>
              <div className="w-full bg-gray-200 rounded-full h-1">
                <div 
                  className="bg-green-600 h-1 rounded-full transition-all duration-300" 
                  style={{ width: `${uploadProgress}%` }}
                ></div>
              </div>
            </div>
          )}

          {isSyncing && (
            <div className="mb-2">
              <div className="flex justify-between items-center mb-1">
                <span className="text-xs text-gray-600">Synchronisation bureau</span>
                <span className="text-xs text-gray-500">{syncProgress}%</span>
              </div>
              <Progress value={syncProgress} className="w-full" />
            </div>
          )}

          {/* Barre de recherche et filtres */}
          <div className="flex items-center justify-between mb-6">
            <div className="relative flex-1 max-w-md">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-4 w-4" />
              <Input
                type="text"
                placeholder="Rechercher des fichiers et dossiers..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="pl-10"
              />
            </div>
            <div className="flex items-center space-x-2">
              <Button
                variant={viewMode === 'grid' ? 'default' : 'outline'}
                size="sm"
                onClick={() => setViewMode('grid')}
              >
                <Grid3X3 className="h-4 w-4" />
              </Button>
              <Button
                variant={viewMode === 'list' ? 'default' : 'outline'}
                size="sm"
                onClick={() => setViewMode('list')}
              >
                <List className="h-4 w-4" />
              </Button>
            </div>
          </div>

          {/* Contenu principal avec défilement vertical optimisé */}
          <div 
            className="flex-1 overflow-y-auto" 
            style={{ 
              minHeight: 0, 
              maxHeight: 'calc(100vh - 280px)',
              overflowY: 'auto',
              scrollBehavior: 'smooth'
            }}
          >
            <div className="space-y-6 pb-24">
              {/* Grille des dossiers */}
              {filteredFolders.length > 0 && (
                <div>
                  <div className="flex items-center justify-between mb-4">
                    <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                      Dossiers ({filteredFolders.length})
                    </h3>
                  </div>
                  <div className="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 xl:grid-cols-10 gap-3">
                    {filteredFolders.map((folder: Folder) => (
                      <div 
                        key={folder.id} 
                        className="group relative border border-gray-200 dark:border-gray-700 rounded-lg p-2 hover:shadow-lg hover:border-blue-300 dark:hover:border-blue-600 transition-all duration-200 cursor-pointer bg-white dark:bg-gray-800"
                        onClick={() => {
                          console.log('[folder-navigation] Entering folder:', folder.id, folder.name);
                          setCurrentFolderId(folder.id);
                        }}
                      >
                        <div className="flex flex-col items-center text-center space-y-1">
                          <div className="h-10 w-10 flex items-center justify-center">
                            {getFolderIcon(folder.iconType)}
                          </div>
                          <div className="w-full">
                            <p className="font-medium text-xs truncate" title={folder.name}>
                              {folder.name}
                            </p>
                            <div className="flex justify-between items-center mt-2">
                              <span className="text-xs text-gray-500">Dossier</span>
                              <DropdownMenu>
                                <DropdownMenuTrigger asChild>
                                  <Button variant="ghost" size="sm">
                                    <MoreVertical className="h-4 w-4" />
                                  </Button>
                                </DropdownMenuTrigger>
                                <DropdownMenuContent align="end">
                                  <DropdownMenuItem
                                    onClick={async (e) => {
                                      e.stopPropagation();
                                      try {
                                        const link = document.createElement('a');
                                        link.href = `/api/folders/${folder.id}/download`;
                                        link.download = `${folder.name}.zip`;
                                        link.target = '_blank';
                                        link.rel = 'noopener noreferrer';
                                        link.style.display = 'none';
                                        document.body.appendChild(link);
                                        link.click();
                                        
                                        setTimeout(() => {
                                          document.body.removeChild(link);
                                        }, 100);
                                        
                                        toast({ 
                                          title: "Téléchargement", 
                                          description: `Téléchargement du dossier ${folder.name} démarré` 
                                        });
                                      } catch (error) {
                                        console.error('Download error:', error);
                                        toast({ 
                                          title: "Erreur", 
                                          description: "Impossible de télécharger le dossier", 
                                          variant: "destructive" 
                                        });
                                      }
                                    }}
                                  >
                                    <Download className="mr-2 h-4 w-4" />
                                    Télécharger
                                  </DropdownMenuItem>
                                  <DropdownMenuItem
                                    onClick={(e) => {
                                      e.stopPropagation();
                                      handleRenameItem(folder.id, folder.name, true);
                                    }}
                                  >
                                    <Edit className="mr-2 h-4 w-4" />
                                    Renommer
                                  </DropdownMenuItem>
                                  <DropdownMenuItem
                                    onClick={(e) => {
                                      e.stopPropagation();
                                      handleShareItem(folder.id, folder.name, true);
                                    }}
                                  >
                                    <Share className="mr-2 h-4 w-4" />
                                    Partager
                                  </DropdownMenuItem>
                                  <DropdownMenuItem
                                    onClick={(e) => {
                                      e.stopPropagation();
                                      handleDeleteItem(folder.id, folder.name, true);
                                    }}
                                    className="text-red-600"
                                  >
                                    <Trash2 className="mr-2 h-4 w-4" />
                                    Supprimer
                                  </DropdownMenuItem>
                                </DropdownMenuContent>
                              </DropdownMenu>
                            </div>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Grille des fichiers */}
              {filteredFiles.length > 0 && (
                <div>
                  <div className="flex items-center justify-between mb-4">
                    <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                      Fichiers ({filteredFiles.length})
                    </h3>
                  </div>
                  <div className="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 xl:grid-cols-10 gap-3">
                    {filteredFiles.map((file: File) => (
                      <div 
                        key={file.id} 
                        className="group relative border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden hover:shadow-lg hover:border-blue-300 dark:hover:border-blue-600 transition-all duration-200 bg-white dark:bg-gray-800"
                      >
                        <div className="h-12 bg-gray-100 dark:bg-gray-700 flex items-center justify-center p-2">
                          {file.type.startsWith('image/') ? (
                            <img src={file.url} alt={file.name} className="h-8 w-8 object-cover rounded" />
                          ) : (
                            <div className="w-6 h-6">
                              {getFileIcon(file.type, file.name)}
                            </div>
                          )}
                        </div>
                        <div className="p-2">
                          <div className="flex justify-between items-start mb-1">
                            <h4 className="font-medium text-xs truncate flex-1 mr-1" title={file.name}>{file.name}</h4>
                            <DropdownMenu>
                              <DropdownMenuTrigger asChild>
                                <Button variant="ghost" size="sm" className="ml-1">
                                  <MoreVertical className="h-4 w-4" />
                                </Button>
                              </DropdownMenuTrigger>
                              <DropdownMenuContent align="end">
                                <DropdownMenuItem
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    // Prévisualisation du fichier
                                    if (file.type.startsWith('image/') || file.type === 'application/pdf' || file.type.startsWith('text/')) {
                                      window.open(file.url, '_blank');
                                    } else {
                                      toast({ 
                                        title: "Prévisualisation", 
                                        description: "Ce type de fichier ne peut pas être prévisualisé", 
                                        variant: "destructive" 
                                      });
                                    }
                                  }}
                                >
                                  <Image className="mr-2 h-4 w-4" />
                                  Prévisualiser
                                </DropdownMenuItem>
                                <DropdownMenuItem
                                  onClick={async (e) => {
                                    e.stopPropagation();
                                    try {
                                      // Méthode de téléchargement améliorée
                                      const link = document.createElement('a');
                                      link.href = file.url;
                                      link.download = file.name;
                                      link.target = '_blank';
                                      link.rel = 'noopener noreferrer';
                                      link.style.display = 'none';
                                      document.body.appendChild(link);
                                      link.click();
                                      
                                      // Nettoyer après un délai
                                      setTimeout(() => {
                                        document.body.removeChild(link);
                                      }, 100);
                                      
                                      toast({ 
                                        title: "Téléchargement", 
                                        description: `Téléchargement de ${file.name} démarré` 
                                      });
                                    } catch (error) {
                                      console.error('Download error:', error);
                                      toast({ 
                                        title: "Erreur", 
                                        description: "Impossible de télécharger le fichier", 
                                        variant: "destructive" 
                                      });
                                    }
                                  }}
                                >
                                  <Download className="mr-2 h-4 w-4" />
                                  Télécharger
                                </DropdownMenuItem>
                                <DropdownMenuItem
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    handleRenameItem(file.id, file.name, false);
                                  }}
                                >
                                  <Edit className="mr-2 h-4 w-4" />
                                  Renommer
                                </DropdownMenuItem>
                                <DropdownMenuItem
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    handleShareItem(file.id, file.name, false);
                                  }}
                                >
                                  <Share className="mr-2 h-4 w-4" />
                                  Partager
                                </DropdownMenuItem>
                                <DropdownMenuItem
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    handleDeleteItem(file.id, file.name, false);
                                  }}
                                  className="text-red-600"
                                >
                                  <Trash2 className="mr-2 h-4 w-4" />
                                  Supprimer
                                </DropdownMenuItem>
                              </DropdownMenuContent>
                            </DropdownMenu>
                          </div>
                          <p className="text-xs text-gray-500 truncate">
                            {formatFileSize(file.size)}
                          </p>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Message si aucun élément */}
              {filteredFolders.length === 0 && filteredFiles.length === 0 && (
                <div className="text-center py-12">
                  <p className="text-gray-500 dark:text-gray-400">
                    {searchTerm ? "Aucun élément trouvé pour cette recherche." : "Ce dossier est vide."}
                  </p>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
